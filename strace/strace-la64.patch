diff --git a/configure.ac b/configure.ac
index 27a547ef9..d17ba04a7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -115,6 +115,11 @@ ia64)
 	arch=ia64
 	AC_DEFINE([IA64], 1, [Define for the IA64 architecture.])
 	;;
+loongarch64)
+	arch=loongarch64
+	karch=loongarch
+	AC_DEFINE([LOONGARCH64], 1, [Define for the 64-bit LoongArch architecture.])
+	;;
 m68k)
 	arch=m68k
 	AC_DEFINE([M68K], 1, [Define for the m68k architecture.])
diff --git a/src/Makefile.am b/src/Makefile.am
index d61696ec0..dc9fd93e7 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -646,6 +646,21 @@ EXTRA_DIST =				\
 	linux/ia64/syscallent.h		\
 	linux/ia64/syscallent_base_nr.h	\
 	linux/ia64/userent.h		\
+	linux/loongarch64/arch_defs_.h	\
+	linux/loongarch64/arch_fpregset.c	\
+	linux/loongarch64/arch_fpregset.h	\
+	linux/loongarch64/arch_prstatus_regset.c	\
+	linux/loongarch64/arch_prstatus_regset.h	\
+	linux/loongarch64/arch_regs.c	\
+	linux/loongarch64/get_error.c	\
+	linux/loongarch64/get_scno.c	\
+	linux/loongarch64/get_syscall_args.c	\
+	linux/loongarch64/ioctls_arch0.h	\
+	linux/loongarch64/ioctls_inc0.h	\
+	linux/loongarch64/raw_syscall.h	\
+	linux/loongarch64/set_error.c	\
+	linux/loongarch64/set_scno.c	\
+	linux/loongarch64/syscallent.h	\
 	linux/m68k/arch_defs_.h		\
 	linux/m68k/arch_regs.c		\
 	linux/m68k/arch_rt_sigframe.c	\
diff --git a/src/linux/loongarch64/arch_defs_.h b/src/linux/loongarch64/arch_defs_.h
new file mode 100644
index 000000000..ffb573326
--- /dev/null
+++ b/src/linux/loongarch64/arch_defs_.h
@@ -0,0 +1,8 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#define PERSONALITY0_AUDIT_ARCH { AUDIT_ARCH_LOONGARCH64, 0 }
diff --git a/src/linux/loongarch64/arch_fpregset.c b/src/linux/loongarch64/arch_fpregset.c
new file mode 100644
index 000000000..0a5ed0a18
--- /dev/null
+++ b/src/linux/loongarch64/arch_fpregset.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2021 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+static void
+arch_decode_fpregset(struct tcb *const tcp,
+		     const kernel_ulong_t addr,
+		     const kernel_ulong_t size)
+{
+	struct_fpregset regs;
+	const size_t fetch_size = MIN(sizeof(regs), size);
+
+	if (!size || size & 7) {
+		printaddr(addr);
+	} else if (!umoven_or_printaddr(tcp, addr, fetch_size, &regs)) {
+		tprint_struct_begin();
+		PRINT_FIELD_ARRAY_UPTO(regs, fpr, fetch_size / 8, tcp,
+				       print_xint_array_member);
+		if (fetch_size > offsetof(struct_fpregset, fcc)) {
+			tprint_struct_next();
+			PRINT_FIELD_X(regs, fcc);
+		}
+		if (fetch_size > offsetof(struct_fpregset, fcsr)) {
+			tprint_struct_next();
+			PRINT_FIELD_X(regs, fcsr);
+		}
+		if (size > sizeof(regs)) {
+			tprint_struct_next();
+			tprint_more_data_follows();
+		}
+		tprint_struct_end();
+	}
+}
diff --git a/src/linux/loongarch64/arch_fpregset.h b/src/linux/loongarch64/arch_fpregset.h
new file mode 100644
index 000000000..998b40f81
--- /dev/null
+++ b/src/linux/loongarch64/arch_fpregset.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#ifndef STRACE_ARCH_FPREGSET_H
+# define STRACE_ARCH_FPREGSET_H
+
+typedef struct user_fp_state struct_fpregset;
+
+# define HAVE_ARCH_FPREGSET 1
+
+#endif /* !STRACE_ARCH_FPREGSET_H */
diff --git a/src/linux/loongarch64/arch_prstatus_regset.c b/src/linux/loongarch64/arch_prstatus_regset.c
new file mode 100644
index 000000000..8df75aa8e
--- /dev/null
+++ b/src/linux/loongarch64/arch_prstatus_regset.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+static void
+arch_decode_prstatus_regset(struct tcb *const tcp,
+			    const kernel_ulong_t addr,
+			    const kernel_ulong_t size)
+{
+	struct_prstatus_regset regs;
+	const size_t fetch_size = MIN(sizeof(regs), size);
+
+	if (!size || size & 7) {
+		printaddr(addr);
+	} else if (!umoven_or_printaddr(tcp, addr, fetch_size, &regs)) {
+		tprint_struct_begin();
+		PRINT_FIELD_ARRAY_UPTO(regs, regs,
+				       fetch_size / 8, tcp,
+				       print_xint_array_member);
+		if (fetch_size > offsetof(struct_prstatus_regset, orig_a0)) {
+			tprint_struct_next();
+			PRINT_FIELD_X(regs, orig_a0);
+		}
+		if (fetch_size > offsetof(struct_prstatus_regset, csr_era)) {
+			tprint_struct_next();
+			PRINT_FIELD_X(regs, csr_era);
+		}
+		if (fetch_size > offsetof(struct_prstatus_regset, csr_badv)) {
+			tprint_struct_next();
+			PRINT_FIELD_X(regs, csr_badv);
+		}
+		const size_t offset_of_reserved =
+			offsetof(struct_prstatus_regset, reserved);
+		if (fetch_size > offset_of_reserved) {
+			tprint_struct_next();
+			PRINT_FIELD_ARRAY_UPTO(regs, reserved,
+					       (fetch_size - offset_of_reserved) / 8,
+					       tcp, print_xint_array_member);
+		}
+		if (size > sizeof(regs)) {
+			tprint_struct_next();
+			tprint_more_data_follows();
+		}
+		tprint_struct_end();
+	}
+}
diff --git a/src/linux/loongarch64/arch_prstatus_regset.h b/src/linux/loongarch64/arch_prstatus_regset.h
new file mode 100644
index 000000000..e7eb64b6c
--- /dev/null
+++ b/src/linux/loongarch64/arch_prstatus_regset.h
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#ifndef STRACE_ARCH_PRSTATUS_REGSET_H
+# define STRACE_ARCH_PRSTATUS_REGSET_H
+
+typedef struct user_pt_regs struct_prstatus_regset;
+
+# define HAVE_ARCH_PRSTATUS_REGSET 1
+
+#endif /* !STRACE_ARCH_PRSTATUS_REGSET_H */
diff --git a/src/linux/loongarch64/arch_regs.c b/src/linux/loongarch64/arch_regs.c
new file mode 100644
index 000000000..509ac8e4f
--- /dev/null
+++ b/src/linux/loongarch64/arch_regs.c
@@ -0,0 +1,11 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+static struct user_pt_regs loongarch_regs;
+#define ARCH_REGS_FOR_GETREGSET loongarch_regs
+#define ARCH_PC_REG loongarch_regs.csr_era
+#define ARCH_SP_REG loongarch_regs.regs[3]
diff --git a/src/linux/loongarch64/get_error.c b/src/linux/loongarch64/get_error.c
new file mode 100644
index 000000000..b52ae28fb
--- /dev/null
+++ b/src/linux/loongarch64/get_error.c
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#include "negated_errno.h"
+
+static void
+arch_get_error(struct tcb *tcp, const bool check_errno)
+{
+	if (check_errno && is_negated_errno(loongarch_regs.regs[4])) {
+		tcp->u_rval = -1;
+		tcp->u_error = -loongarch_regs.regs[4];
+	} else {
+		tcp->u_rval = loongarch_regs.regs[4];
+	}
+}
diff --git a/src/linux/loongarch64/get_scno.c b/src/linux/loongarch64/get_scno.c
new file mode 100644
index 000000000..cb0f42cae
--- /dev/null
+++ b/src/linux/loongarch64/get_scno.c
@@ -0,0 +1,14 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+/* Return codes: 1 - ok, 0 - ignore, other - error. */
+static int
+arch_get_scno(struct tcb *tcp)
+{
+	tcp->scno = loongarch_regs.regs[11];
+	return 1;
+}
diff --git a/src/linux/loongarch64/get_syscall_args.c b/src/linux/loongarch64/get_syscall_args.c
new file mode 100644
index 000000000..e97aa7274
--- /dev/null
+++ b/src/linux/loongarch64/get_syscall_args.c
@@ -0,0 +1,19 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+/* Return -1 on error or 1 on success (never 0!). */
+static int
+arch_get_syscall_args(struct tcb *tcp)
+{
+	tcp->u_arg[0] = loongarch_regs.orig_a0;
+	tcp->u_arg[1] = loongarch_regs.regs[5];
+	tcp->u_arg[2] = loongarch_regs.regs[6];
+	tcp->u_arg[3] = loongarch_regs.regs[7];
+	tcp->u_arg[4] = loongarch_regs.regs[8];
+	tcp->u_arg[5] = loongarch_regs.regs[9];
+	return 1;
+}
diff --git a/src/linux/loongarch64/ioctls_arch0.h b/src/linux/loongarch64/ioctls_arch0.h
new file mode 100644
index 000000000..59d8aaa9a
--- /dev/null
+++ b/src/linux/loongarch64/ioctls_arch0.h
@@ -0,0 +1 @@
+/* Generated by ioctls_gen.sh from definitions found in $linux/arch/loongarch/include/ tree. */
diff --git a/src/linux/loongarch64/ioctls_inc0.h b/src/linux/loongarch64/ioctls_inc0.h
new file mode 100644
index 000000000..6028afbe4
--- /dev/null
+++ b/src/linux/loongarch64/ioctls_inc0.h
@@ -0,0 +1 @@
+#include "../64/ioctls_inc.h"
diff --git a/src/linux/loongarch64/raw_syscall.h b/src/linux/loongarch64/raw_syscall.h
new file mode 100644
index 000000000..122777898
--- /dev/null
+++ b/src/linux/loongarch64/raw_syscall.h
@@ -0,0 +1,29 @@
+/*
+ * Raw syscalls.
+ *
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#ifndef STRACE_RAW_SYSCALL_H
+# define STRACE_RAW_SYSCALL_H
+
+# include "kernel_types.h"
+
+static inline kernel_ulong_t
+raw_syscall_0(const kernel_ulong_t nr, kernel_ulong_t *err)
+{
+	*err = 0;
+	register kernel_ulong_t a7 __asm__("a7") = nr;
+	register kernel_ulong_t a0 __asm__("a0");
+	__asm__ __volatile__("syscall 0"
+			     : "=r"(a0)
+			     : "r"(a7)
+			     : "memory");
+	return a0;
+}
+# define raw_syscall_0 raw_syscall_0
+
+#endif /* !STRACE_RAW_SYSCALL_H */
diff --git a/src/linux/loongarch64/set_error.c b/src/linux/loongarch64/set_error.c
new file mode 100644
index 000000000..aa83a3e02
--- /dev/null
+++ b/src/linux/loongarch64/set_error.c
@@ -0,0 +1,20 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+static int
+arch_set_error(struct tcb *tcp)
+{
+	loongarch_regs.regs[4] = -tcp->u_error;
+	return set_regs(tcp->pid);
+}
+
+static int
+arch_set_success(struct tcb *tcp)
+{
+	loongarch_regs.regs[4] = tcp->u_rval;
+	return set_regs(tcp->pid);
+}
diff --git a/src/linux/loongarch64/set_scno.c b/src/linux/loongarch64/set_scno.c
new file mode 100644
index 000000000..d338f2068
--- /dev/null
+++ b/src/linux/loongarch64/set_scno.c
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+static int
+arch_set_scno(struct tcb *tcp, kernel_ulong_t scno)
+{
+	if (ptrace_syscall_info_is_valid() && get_regs(tcp) < 0)
+		return -1;
+	loongarch_regs.regs[11] = scno;
+	return set_regs(tcp->pid);
+}
diff --git a/src/linux/loongarch64/syscallent.h b/src/linux/loongarch64/syscallent.h
new file mode 100644
index 000000000..5ab228bfb
--- /dev/null
+++ b/src/linux/loongarch64/syscallent.h
@@ -0,0 +1,8 @@
+/*
+ * Copyright (c) 2021-2022 The strace developers.
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: LGPL-2.1-or-later
+ */
+
+#include "../64/syscallent.h"
diff --git a/src/xlat/elf_em.in b/src/xlat/elf_em.in
index 116b18292..6d9bf80a0 100644
--- a/src/xlat/elf_em.in
+++ b/src/xlat/elf_em.in
@@ -190,6 +190,7 @@ EM_AMDGPU		224 /* AMD GPU architecture */
 EM_RISCV		243 /* RISC-V */
 EM_BPF			247 /* Linux BPF - in-kernel virtual machine */
 EM_CSKY			252 /* C-SKY */
+EM_LOONGARCH		258 /* LoongArch */
 EM_AVR32		0x18ad /* Atmel AVR32, removed in v4.12-rc1~159^2~5 */
 EM_FRV			0x5441 /* Fujitsu FR-V */
 EM_OR32			0x8472 /* arch/openrisc/include/uapi/asm/elf.h */
diff --git a/tests/ptrace.c b/tests/ptrace.c
index e53639c1b..0ecd3c7b7 100644
--- a/tests/ptrace.c
+++ b/tests/ptrace.c
@@ -205,7 +205,7 @@ test_peeksiginfo(int pid, const unsigned long bad_request)
 # define TRACEE_REGS_STRUCT struct pt_regs
 #elif defined __arm__
 # define TRACEE_REGS_STRUCT struct pt_regs
-#elif defined __arm64__ || defined __aarch64__
+#elif defined __arm64__ || defined __aarch64__ || defined __loongarch__
 # define TRACEE_REGS_STRUCT struct user_pt_regs
 #elif defined __s390__ || defined __s390x__
 # define TRACEE_REGS_STRUCT s390_regs
@@ -843,11 +843,51 @@ print_prstatus_regset(const void *const rs, const size_t size)
 		PRINT_FIELD_X(*regs, cp0_cause);
 	}
 
+# elif defined __loongarch__
+
+	if (size > offsetof(TRACEE_REGS_STRUCT, regs)) {
+		const size_t len = size - offsetof(TRACEE_REGS_STRUCT, regs);
+		fputs("regs=[", stdout);
+		for (unsigned int i = 0; i < ARRAY_SIZE(regs->regs); ++i) {
+			if (len > i * sizeof(regs->regs[i])) {
+				if (i)
+					fputs(", ", stdout);
+				PRINT_VAL_X(regs->regs[i]);
+			}
+		}
+		fputs("]", stdout);
+	}
+	if (size >= offsetofend(TRACEE_REGS_STRUCT, orig_a0)) {
+		fputs(", ", stdout);
+		PRINT_FIELD_X(*regs, orig_a0);
+	}
+	if (size >= offsetofend(TRACEE_REGS_STRUCT, csr_era)) {
+		fputs(", ", stdout);
+		PRINT_FIELD_X(*regs, csr_era);
+	}
+	if (size >= offsetofend(TRACEE_REGS_STRUCT, csr_badv)) {
+		fputs(", ", stdout);
+		PRINT_FIELD_X(*regs, csr_badv);
+	}
+	if (size > offsetof(TRACEE_REGS_STRUCT, reserved)) {
+		const size_t len = size - offsetof(TRACEE_REGS_STRUCT, reserved);
+		fputs(", reserved=[", stdout);
+		for (unsigned int i = 0; i < ARRAY_SIZE(regs->reserved); ++i) {
+			if (len > i * sizeof(regs->reserved[i])) {
+				if (i)
+					fputs(", ", stdout);
+				PRINT_VAL_X(regs->reserved[i]);
+			}
+		}
+		fputs("]", stdout);
+	}
+
 # endif /*
 	   __aarch64__ ||
 	   __arm64__ ||
 	   __arm__ ||
 	   __i386__ ||
+	   __loongarch__ ||
 	   __mips__ ||
 	   __powerpc64__ ||
 	   __powerpc__ ||
@@ -1085,6 +1125,8 @@ typedef struct {
 	uint64_t fpscr;
 } ppc_fpregs_struct;
 # define TRACEE_REGS_STRUCT ppc_fpregs_struct
+#elif defined __loongarch__
+# define TRACEE_REGS_STRUCT struct user_fp_state
 #endif
 
 static void
@@ -1228,8 +1270,29 @@ print_fpregset(const void *const rs, const size_t size)
 		PRINT_FIELD_X(*regs, fpscr);
 	}
 
+# elif defined __loongarch__
+
+	fputs("fpr=[", stdout);
+	for (unsigned int i = 0; i < ARRAY_SIZE(regs->fpr); ++i) {
+		if (size > i * sizeof(regs->fpr[i])) {
+			if (i)
+				fputs(", ", stdout);
+			PRINT_VAL_X(regs->fpr[i]);
+		}
+	}
+	fputs("]", stdout);
+	if (size >= offsetofend(TRACEE_REGS_STRUCT, fcc)) {
+		fputs(", ", stdout);
+		PRINT_FIELD_X(*regs, fcc);
+	}
+	if (size >= offsetofend(TRACEE_REGS_STRUCT, fcsr)) {
+		fputs(", ", stdout);
+		PRINT_FIELD_X(*regs, fcsr);
+	}
+
 # endif /*
 	   __i386__ ||
+	   __loongarch__ ||
 	   __powerpc64__ ||
 	   __powerpc__ ||
 	   __x86_64__
